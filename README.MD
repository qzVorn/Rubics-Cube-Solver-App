# ğŸ§Š 3D Rubik's Cube Solver

An interactive, zero-dependency Rubik's Cube solver that runs entirely in a single HTML file. Users paint sticker colors onto a fully rotatable 3D cube, then watch a step-by-step animated solution powered by Herbert Kociemba's Two-Phase Algorithm.

![HTML5](https://img.shields.io/badge/HTML5-E34F26?style=flat&logo=html5&logoColor=white)
![JavaScript](https://img.shields.io/badge/JavaScript-ES6+-F7DF1E?style=flat&logo=javascript&logoColor=black)
![CSS3](https://img.shields.io/badge/CSS3-1572B6?style=flat&logo=css3&logoColor=white)
![License: MIT](https://img.shields.io/badge/License-MIT-green.svg)

---

## Table of Contents

- [Summary](#summary)
- [Features](#features)
- [Getting Started](#getting-started)
- [Architecture Overview](#architecture-overview)
- [Cube State Representation](#cube-state-representation)
  - [Facelet Indexing](#facelet-indexing)
  - [Color Mapping](#color-mapping)
  - [Dual Source-of-Truth Model](#dual-source-of-truth-model)
- [The Solver: Kociemba's Two-Phase Algorithm](#the-solver-kociembas-two-phase-algorithm)
  - [How It Works](#how-it-works)
  - [Phase 1: Reduce to G1](#phase-1-reduce-to-g1)
  - [Phase 2: Solve from G1](#phase-2-solve-from-g1)
  - [Integration via cubejs](#integration-via-cubejs)
- [3D Rendering Engine](#3d-rendering-engine)
  - [Coordinate System](#coordinate-system)
  - [Rotation Matrices](#rotation-matrices)
  - [Perspective Projection](#perspective-projection)
  - [Painter's Algorithm](#painters-algorithm)
  - [Mouse/Touch Orbit Controls](#mousetouch-orbit-controls)
- [Move System](#move-system)
  - [Move Notation](#move-notation)
  - [Applying Moves to State](#applying-moves-to-state)
  - [Animated Transitions](#animated-transitions)
- [Scramble Generation](#scramble-generation)
- [Validation Logic](#validation-logic)
- [UI Components](#ui-components)
  - [Color Palette and Painting](#color-palette-and-painting)
  - [2D Net View](#2d-net-view)
  - [Step-by-Step Playback](#step-by-step-playback)
- [Customization Guide](#customization-guide)
  - [Changing Cube Colors](#changing-cube-colors)
  - [Adjusting Scramble Length](#adjusting-scramble-length)
  - [Modifying Animation Speed](#modifying-animation-speed)
  - [Canvas and Layout Sizing](#canvas-and-layout-sizing)
  - [Adding New Move Descriptions](#adding-new-move-descriptions)
- [Troubleshooting](#troubleshooting)
- [Dependencies](#dependencies)
- [Project Structure](#project-structure)
- [Contributing](#contributing)
- [License](#license)
- [Acknowledgments](#acknowledgments)

---

## Summary

This project is a fully self-contained, browser-based Rubik's Cube solver. It requires no build tools, no package manager, no server, and no external CDN â€” everything lives in a single `index.html` file.

The user interacts with the cube in two phases:

1. **Paint Phase** â€” Click stickers on an interactive 3D cube (with full 360Â° mouse/touch rotation) or on a 2D unfolded net to assign colors. A real-time counter ensures exactly 9 stickers per color.
2. **Solve Phase** â€” The Kociemba Two-Phase Algorithm computes a near-optimal solution (â‰¤ 22 moves). The solution is displayed as a numbered step list with plain-English descriptions, and each move is animated on the 3D cube with full forward/backward navigation.

The solver engine is [cubejs](https://github.com/ldez/cubejs) by Petri Lehtinen (akheron), inlined directly into the HTML file. It implements Herbert Kociemba's Two-Phase Algorithm in JavaScript, finding solutions in 0.01â€“0.4 seconds after an initial 4â€“5 second precalculation step.

---

## Features

- **Zero Dependencies** â€” Single HTML file, no npm, no CDN, no build step.
- **Interactive 3D Cube** â€” Pure Canvas 2D API with manual 3D projection; mouse drag to orbit, touch-friendly.
- **Full Sticker Editing** â€” All 54 stickers are paintable, including centers.
- **Real-Time Validation** â€” Live color counter (X/9 per color) with error detection.
- **Kociemba Solver** â€” Near-optimal solutions in â‰¤ 22 moves, computed in milliseconds.
- **Step-by-Step Playback** â€” Forward, backward, play/pause, speed control, progress bar.
- **Smooth Animations** â€” Per-layer rotation animations with configurable duration and easing.
- **Random Scramble** â€” Generates guaranteed-solvable random states via move sequences.
- **Responsive Layout** â€” Three-panel design (palette, 3D view, steps) that adapts to screen size.
- **Standard Colors** â€” Uses official Rubik's Cube colors: White, Yellow, Red, Orange, Blue, Green.

---

## Getting Started

```bash
# Clone the repository
git clone https://github.com/your-username/rubiks-cube-solver.git
cd rubiks-cube-solver

# Open in your browser â€” that's it
open index.html
# or
xdg-open index.html   # Linux
start index.html       # Windows
```

No server required. No compilation. Just open the file.

> **Note:** On first load, the solver performs a one-time precalculation (~4â€“5 seconds) to build lookup/pruning tables. A status indicator shows progress.

---

## Architecture Overview

The application is structured as three logical layers within a single file:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        index.html                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  <style>        â€” All CSS (layout, palette, animations)  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  <script>       â€” cubejs library (cube.js + solve.js)    â”‚
â”‚                    Kociemba Two-Phase Algorithm           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  <script>       â€” Application logic                      â”‚
â”‚                    â”œâ”€â”€ State management                   â”‚
â”‚                    â”œâ”€â”€ 3D rendering engine                â”‚
â”‚                    â”œâ”€â”€ UI event handlers                  â”‚
â”‚                    â”œâ”€â”€ Validation                         â”‚
â”‚                    â”œâ”€â”€ Move animation system              â”‚
â”‚                    â””â”€â”€ Step playback controller           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Cube State Representation

### Facelet Indexing

The cube state is stored as a flat array of 54 elements, indexed 0â€“53. Each element represents one sticker (facelet). The mapping follows the standard cubejs convention:

```
Indices 0â€“8:   U face (Up/Top)       â€” White
Indices 9â€“17:  R face (Right)        â€” Red
Indices 18â€“26: F face (Front)        â€” Green
Indices 27â€“35: D face (Down/Bottom)  â€” Yellow
Indices 36â€“44: L face (Left)         â€” Orange
Indices 45â€“53: B face (Back)         â€” Blue
```

Within each face, stickers are ordered left-to-right, top-to-bottom:

```
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚  0    1    2   â”‚
              â”‚                â”‚
              â”‚  3    4    5   â”‚
              â”‚                â”‚
              â”‚  6    7    8   â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 36  37  38  â”‚ 18   19   20  â”‚  9   10  11  â”‚ 45  46  47  â”‚
â”‚             â”‚               â”‚              â”‚             â”‚
â”‚ 39  40  41  â”‚ 21   22   23  â”‚ 12   13  14  â”‚ 48  49  50  â”‚
â”‚             â”‚               â”‚              â”‚             â”‚
â”‚ 42  43  44  â”‚ 24   25   26  â”‚ 15   16  17  â”‚ 51  52  53  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚ 27   28   29  â”‚
              â”‚               â”‚
              â”‚ 30   31   32  â”‚
              â”‚               â”‚
              â”‚ 33   34   35  â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       L            F              R              B
                    U (top)
                    D (bottom)
```

The six center stickers (which define each face's identity) are at indices **4, 13, 22, 31, 40, 49**.

### Color Mapping

The application uses two parallel representations: display colors (what the user sees) and solver characters (what cubejs expects).

```javascript
// â”€â”€ Display Colors â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Customize these hex values to change the cube's appearance.
const DISPLAY_COLORS = {
  W: '#ffffff',   // White  â€” Up face
  Y: '#ffd700',   // Yellow â€” Down face
  R: '#dc3545',   // Red    â€” Right face
  O: '#ff8c00',   // Orange â€” Left face
  B: '#003da5',   // Blue   â€” Back face
  G: '#009b48',   // Green  â€” Front face
};

// â”€â”€ Face-to-Color Mapping â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Maps cubejs face letters to display color keys.
const FACE_TO_COLOR = {
  U: 'W',  // Up    â†’ White
  R: 'R',  // Right â†’ Red
  F: 'G',  // Front â†’ Green
  D: 'Y',  // Down  â†’ Yellow
  L: 'O',  // Left  â†’ Orange
  B: 'B',  // Back  â†’ Blue
};
```

### Dual Source-of-Truth Model

A critical design decision is using **two separate state models** for painting and solving to prevent state drift:

```javascript
// â”€â”€ Paint Mode â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// paintedColors[] is the sole source of truth while the user
// is editing stickers. It stores color keys ('W','Y','R',...).
let paintedColors = new Array(54).fill('W');

// â”€â”€ Solve Mode â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// cubeObj is a native cubejs Cube object â€” the sole source of
// truth during solution playback. Display colors are derived
// on-the-fly from cubeObj.asString().
let cubeObj = null;

// â”€â”€ Saved Checkpoint â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// When the user clicks "Solve", the exact cubejs state is
// saved. Navigating to any step restores this checkpoint and
// re-applies moves 0..N, guaranteeing perfect state.
let savedCubeJSON = null;

let mode = 'paint'; // 'paint' | 'solve'
```

**Why two models?** Converting back and forth between display colors and cubejs strings on every move caused cumulative rounding/mapping errors. The dual model ensures the solver's internal state is never corrupted by display logic.

```javascript
// â”€â”€ Convert display colors â†’ cubejs string â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function colorsToCubeString(colors) {
  const centers = [4, 13, 22, 31, 40, 49];
  const faces = ['U', 'R', 'F', 'D', 'L', 'B'];
  const map = {};
  faces.forEach((f, i) => {
    map[colors[centers[i]]] = f;
  });
  return colors.map(c => map[c]).join('');
}

// â”€â”€ Convert cubejs string â†’ display colors â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function cubeStringToColors(str) {
  const centers = [4, 13, 22, 31, 40, 49];
  const faces = ['U', 'R', 'F', 'D', 'L', 'B'];
  const map = {};
  faces.forEach((f, i) => {
    map[str[centers[i]]] = FACE_TO_COLOR[f];
  });
  return str.split('').map(ch => map[ch]);
}
```

---

## The Solver: Kociemba's Two-Phase Algorithm

### How It Works

Herbert Kociemba's Two-Phase Algorithm is one of the most efficient methods for solving a 3Ã—3Ã—3 Rubik's Cube. Unlike beginner layer-by-layer methods (which may produce 80+ move solutions), Kociemba finds near-optimal solutions of **â‰¤ 22 moves** â€” close to the theoretical minimum of 20 moves (God's Number).

The algorithm divides the solution into two phases by exploiting the algebraic group structure of the cube:

```
All cube states (G0)  â”€â”€Phase 1â”€â”€â–º  Restricted subgroup (G1)  â”€â”€Phase 2â”€â”€â–º  Solved (Identity)
    ~4.3 Ã— 10Â¹â¹                      ~1.95 Ã— 10Â¹â°                              1
     states                             states                                 state
```

### Phase 1: Reduce to G1

**Goal:** Transform the scrambled cube into the subgroup G1 = âŸ¨U, D, RÂ², LÂ², FÂ², BÂ²âŸ©.

A cube is in G1 when three conditions are met simultaneously:

| Condition | Description | Coordinate Range |
|-----------|-------------|-----------------|
| Corner Orientation | All 8 corners have orientation 0 | 0â€“2,186 |
| Edge Orientation | All 12 edges have orientation 0 | 0â€“2,047 |
| UD-Slice Edges | The 4 middle-layer edges (FR, FL, BL, BR) are somewhere in the middle layer | 0â€“494 |

Phase 1 searches through **2,187 Ã— 2,048 Ã— 495 â‰ˆ 2.22 billion** states using all 18 face moves (U, U', U2, R, R', R2, F, F', F2, D, D', D2, L, L', L2, B, B', B2).

### Phase 2: Solve from G1

**Goal:** Solve the cube from the G1 state to the identity (solved) state.

| Condition | Description | Coordinate Range |
|-----------|-------------|-----------------|
| Corner Permutation | All 8 corners in correct position | 0â€“40,319 |
| Edge Permutation (U/D) | All 8 U/D edges in correct position | 0â€“40,319 |
| UD-Slice Permutation | The 4 middle-layer edges in correct order | 0â€“23 |

Phase 2 searches through **40,320 Ã— 40,320 Ã— 24 / 2 â‰ˆ 19.5 billion** states using only the restricted move set: {U, U', U2, D, D', D2, RÂ², LÂ², FÂ², BÂ²} (10 moves). These moves preserve the G1 conditions established in Phase 1.

The algorithm uses **Iterative Deepening A\* (IDA\*)** with precomputed **pruning tables** to dramatically reduce the search space. It iteratively tries longer Phase 1 solutions hoping for shorter Phase 2 solutions, keeping the best total.

### Integration via cubejs

The [cubejs](https://github.com/ldez/cubejs) library by Petri Lehtinen provides the JavaScript implementation. It is inlined directly in the HTML file (no external fetch).

```javascript
// â”€â”€ Solver Initialization â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Must be called once before any solve() calls.
// Builds move tables and pruning tables (~4-5 seconds).
Cube.initSolver();

// â”€â”€ Solving a Cube â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Create a Cube from a 54-character facelet string and solve.
const cubeString = colorsToCubeString(paintedColors);
const cubeObj = Cube.fromString(cubeString);
const solution = cubeObj.solve();
// solution = "R U' F2 D B' L2 ..." (string of moves)

// â”€â”€ Applying Moves â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
cubeObj.move("R U' F2");  // Apply moves to internal state
const newFacelets = cubeObj.asString(); // Get updated state

// â”€â”€ State Serialization â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const checkpoint = cubeObj.toJSON();
// { cp: [...], co: [...], ep: [...], eo: [...] }
const restored = new Cube(checkpoint); // Perfect restoration
```

**Key cubejs API methods used in this project:**

| Method | Purpose |
|--------|---------|
| `new Cube()` | Create a solved cube instance |
| `Cube.fromString(str)` | Create cube from 54-char facelet string |
| `Cube.initSolver()` | Build lookup/pruning tables (one-time) |
| `Cube.random()` | Generate a random cube state |
| `cube.solve()` | Return solution string (â‰¤ 22 moves) |
| `cube.move(alg)` | Apply move sequence to cube |
| `cube.asString()` | Export cube as 54-char facelet string |
| `cube.toJSON()` | Serialize state as JSON object |
| `cube.isSolved()` | Check if cube is the identity |
| `new Cube(json)` | Restore cube from serialized state |

---

## 3D Rendering Engine

The cube is rendered using the **HTML5 Canvas 2D API** with manual 3D math â€” no WebGL, no Three.js, no libraries. This keeps the project dependency-free and broadly compatible.

### Coordinate System

Each of the 26 visible cubies is defined by its 3D position on a grid centered at the origin. Each sticker is a quadrilateral (4 vertices) in 3D space, offset slightly from the cubie surface.

```javascript
// â”€â”€ Cubie Geometry â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Each cubie occupies a 1Ã—1Ã—1 unit cell. The full cube spans
// from -1.5 to +1.5 on each axis. Stickers are inset by a
// small gap for the black border effect.

const CUBIE_SIZE = 1.0;       // Size of one cubie
const GAP = 0.05;             // Gap between stickers (black border)
const STICKER_INSET = 0.08;   // Inset from cubie edge

// Example: Front face sticker at grid position (row=0, col=0)
// 3D corners before rotation:
// (-1.5 + GAP, 1.5 - GAP, 1.5)   top-left
// (-0.5 - GAP, 1.5 - GAP, 1.5)   top-right
// (-0.5 - GAP, 0.5 + GAP, 1.5)   bottom-right
// (-1.5 + GAP, 0.5 + GAP, 1.5)   bottom-left
```

### Rotation Matrices

User orbiting and face-turn animations use standard 3D rotation matrices applied to every vertex before projection.

```javascript
// â”€â”€ Rotation around X axis â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function rotateX(point, angle) {
  const cos = Math.cos(angle);
  const sin = Math.sin(angle);
  return [
    point[0],
    point[1] * cos - point[2] * sin,
    point[1] * sin + point[2] * cos,
  ];
}

// â”€â”€ Rotation around Y axis â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function rotateY(point, angle) {
  const cos = Math.cos(angle);
  const sin = Math.sin(angle);
  return [
    point[0] * cos + point[2] * sin,
    point[1],
   -point[0] * sin + point[2] * cos,
  ];
}

// â”€â”€ Rotation around Z axis â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function rotateZ(point, angle) {
  const cos = Math.cos(angle);
  const sin = Math.sin(angle);
  return [
    point[0] * cos - point[1] * sin,
    point[0] * sin + point[1] * cos,
    point[2],
  ];
}
```

Orbit rotation is applied as a combined Y-then-X rotation controlled by mouse/touch drag deltas:

```javascript
// â”€â”€ Apply orbit rotation to a point â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function applyOrbit(point) {
  let p = rotateY(point, orbitAngleY);
  p = rotateX(p, orbitAngleX);
  return p;
}
```

### Perspective Projection

3D points are projected to 2D canvas coordinates using a simple perspective (pinhole camera) projection:

```javascript
// â”€â”€ Perspective Projection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const CAMERA_DISTANCE = 8;  // Distance from camera to origin
const PROJECTION_SCALE = 200; // Pixels per unit at z=0

function project(point3D) {
  const [x, y, z] = point3D;
  const scale = CAMERA_DISTANCE / (CAMERA_DISTANCE - z);
  return {
    x: canvasCenterX + x * PROJECTION_SCALE * scale,
    y: canvasCenterY - y * PROJECTION_SCALE * scale, // Y is inverted
    depth: z, // Retained for sorting
  };
}
```

**Customizable parameters:**

| Variable | Default | Effect |
|----------|---------|--------|
| `CAMERA_DISTANCE` | `8` | Larger = less perspective distortion (more orthographic) |
| `PROJECTION_SCALE` | `200` | Larger = bigger cube on screen |

### Painter's Algorithm

Since we use Canvas 2D (no z-buffer), faces are drawn back-to-front using the **Painter's Algorithm**:

```javascript
// â”€â”€ Sort stickers by average depth (back to front) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
stickers.sort((a, b) => {
  const avgDepthA = a.projectedVerts.reduce((s, v) => s + v.depth, 0) / 4;
  const avgDepthB = b.projectedVerts.reduce((s, v) => s + v.depth, 0) / 4;
  return avgDepthA - avgDepthB; // Draw furthest first
});

// â”€â”€ Draw each sticker as a filled polygon â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
stickers.forEach(sticker => {
  ctx.beginPath();
  ctx.moveTo(sticker.projectedVerts[0].x, sticker.projectedVerts[0].y);
  for (let i = 1; i < 4; i++) {
    ctx.lineTo(sticker.projectedVerts[i].x, sticker.projectedVerts[i].y);
  }
  ctx.closePath();
  ctx.fillStyle = DISPLAY_COLORS[sticker.color];
  ctx.fill();
  ctx.strokeStyle = '#000';
  ctx.lineWidth = 2;
  ctx.stroke();
});
```

### Mouse/Touch Orbit Controls

The cube can be freely rotated by dragging. The implementation tracks pointer movement and updates orbit angles:

```javascript
// â”€â”€ Mouse/Touch Orbit â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let isDragging = false;
let lastPointerX, lastPointerY;
let orbitAngleX = -Math.PI / 6; // Initial tilt (30Â° down)
let orbitAngleY = Math.PI / 5;  // Initial rotation

const ORBIT_SENSITIVITY = 0.007; // Radians per pixel of drag

canvas.addEventListener('pointerdown', (e) => {
  isDragging = true;
  lastPointerX = e.clientX;
  lastPointerY = e.clientY;
});

canvas.addEventListener('pointermove', (e) => {
  if (!isDragging) return;
  const dx = e.clientX - lastPointerX;
  const dy = e.clientY - lastPointerY;
  orbitAngleY += dx * ORBIT_SENSITIVITY;
  orbitAngleX += dy * ORBIT_SENSITIVITY;
  // Clamp vertical rotation to prevent flipping
  orbitAngleX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, orbitAngleX));
  lastPointerX = e.clientX;
  lastPointerY = e.clientY;
  render(); // Re-draw with new angles
});

canvas.addEventListener('pointerup', () => { isDragging = false; });
```

---

## Move System

### Move Notation

Standard Rubik's Cube notation is used throughout. Each move is a face letter optionally followed by a modifier:

| Move | Description | Degrees |
|------|-------------|---------|
| `U` | Up face clockwise (90Â°) | 90Â° CW |
| `U'` | Up face counter-clockwise (90Â°) | 90Â° CCW |
| `U2` | Up face half-turn (180Â°) | 180Â° |
| `R` | Right face clockwise | 90Â° CW |
| `R'` | Right face counter-clockwise | 90Â° CCW |
| `R2` | Right face half-turn | 180Â° |
| `F` | Front face clockwise | 90Â° CW |
| `D` | Down face clockwise | 90Â° CW |
| `L` | Left face clockwise | 90Â° CW |
| `B` | Back face clockwise | 90Â° CW |

*(Primed `'` and double `2` variants exist for all six faces.)*

### Applying Moves to State

Moves are applied to the cubejs `Cube` object directly. The display is then derived from the updated state:

```javascript
// â”€â”€ Apply a single move and update display â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function applyMove(moveStr) {
  cubeObj.move(moveStr);
  const colors = cubeStringToColors(cubeObj.asString());
  updateDisplayFromColors(colors);
}
```

### Animated Transitions

Move animations rotate the affected layer's stickers smoothly over a configurable duration. The system identifies which of the 54 stickers belong to the turning layer, then applies an incremental rotation to only those stickers during each animation frame.

```javascript
// â”€â”€ Animation Configuration â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const ANIMATION_DURATION_MS = 400;  // Milliseconds per move
const ANIMATION_EASING = 'ease';     // CSS-style easing name

// â”€â”€ Layer Sets â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Precomputed mapping: face â†’ set of facelet indices that
// rotate when that face turns. Built dynamically at init by
// applying a test move and diffing the before/after state.
let layerSets = {};

function buildLayerSets() {
  const faces = ['U', 'R', 'F', 'D', 'L', 'B'];
  faces.forEach(face => {
    const before = new Cube();
    const after = new Cube();
    after.move(face);
    const bStr = before.asString();
    const aStr = after.asString();
    const indices = new Set();
    for (let i = 0; i < 54; i++) {
      if (bStr[i] !== aStr[i]) indices.add(i);
    }
    layerSets[face] = indices;
  });
}

// â”€â”€ Animate a Move â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function applyMoveAnimated(moveStr, callback) {
  const face = moveStr[0];
  const isPrime = moveStr.includes("'");
  const isDouble = moveStr.includes("2");
  const targetAngle = isDouble ? Math.PI : Math.PI / 2;
  const direction = isPrime ? -1 : 1;
  const axis = getAxisForFace(face); // 'x', 'y', or 'z'
  const affectedIndices = layerSets[face];

  const startTime = performance.now();

  function frame(now) {
    const elapsed = now - startTime;
    const t = Math.min(elapsed / ANIMATION_DURATION_MS, 1);
    // Ease-in-out
    const eased = t < 0.5
      ? 2 * t * t
      : 1 - Math.pow(-2 * t + 2, 2) / 2;
    const angle = eased * targetAngle * direction;

    renderWithLayerRotation(affectedIndices, axis, angle);

    if (t < 1) {
      requestAnimationFrame(frame);
    } else {
      cubeObj.move(moveStr); // Commit move to state
      render();              // Clean render from new state
      if (callback) callback();
    }
  }

  requestAnimationFrame(frame);
}
```

---

## Scramble Generation

Random scrambles are generated by applying a sequence of random moves to a solved cube, rather than using `Cube.random()`. This guarantees that center stickers remain in their standard positions, avoiding the center-permutation issues that caused "invalid sticker count" errors.

```javascript
// â”€â”€ Scramble Configuration â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const SCRAMBLE_MOVE_COUNT = 25; // Number of random moves

const MOVE_FACES = ['U', 'R', 'F', 'D', 'L', 'B'];
const MOVE_SUFFIXES = ['', "'", '2'];

function randomizeCube() {
  // Start from solved state
  const cube = new Cube();
  let lastFace = '';
  const moves = [];

  for (let i = 0; i < SCRAMBLE_MOVE_COUNT; i++) {
    let face;
    do {
      face = MOVE_FACES[Math.floor(Math.random() * 6)];
    } while (face === lastFace); // Avoid consecutive same-face moves

    const suffix = MOVE_SUFFIXES[Math.floor(Math.random() * 3)];
    const move = face + suffix;
    cube.move(move);
    moves.push(move);
    lastFace = face;
  }

  // Extract display colors from the scrambled state
  paintedColors = cubeStringToColors(cube.asString());
  mode = 'paint';
  updateUI();
}
```

**Why not `Cube.random()`?** The `Cube.random()` method randomizes corner/edge permutation and orientation but can create states where â€” when converted to a facelet string â€” the center stickers don't match the expected U/R/F/D/L/B positions. This caused the solver to reject the cube. Generating scrambles via move sequences preserves center identity.

---

## Validation Logic

Before solving, the cube state is validated to catch impossible or incorrectly painted configurations:

```javascript
function validateCube(colors) {
  const errors = [];

  // 1. Check that each color appears exactly 9 times
  const counts = {};
  Object.keys(DISPLAY_COLORS).forEach(c => { counts[c] = 0; });
  colors.forEach(c => { counts[c] = (counts[c] || 0) + 1; });

  for (const [color, count] of Object.entries(counts)) {
    if (count !== 9) {
      errors.push(`${color} has ${count} stickers (need exactly 9)`);
    }
  }

  // 2. Check that all 6 center stickers are unique colors
  const centers = [4, 13, 22, 31, 40, 49];
  const centerColors = new Set(centers.map(i => colors[i]));
  if (centerColors.size !== 6) {
    errors.push('All 6 center stickers must be different colors');
  }

  return errors; // Empty array = valid
}
```

The solver also catches **impossible permutations** (e.g., a single flipped edge or twisted corner) by trapping the exception from `cubeObj.solve()` and displaying a helpful error message.

---

## UI Components

### Color Palette and Painting

The left panel displays clickable color swatches and a live sticker counter:

```javascript
// â”€â”€ Build Color Swatches â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const PALETTE_ORDER = ['W', 'Y', 'R', 'O', 'B', 'G'];

function buildPalette(container) {
  PALETTE_ORDER.forEach(colorKey => {
    const swatch = document.createElement('div');
    swatch.className = 'color-swatch';
    swatch.style.backgroundColor = DISPLAY_COLORS[colorKey];
    swatch.dataset.color = colorKey;
    swatch.addEventListener('click', () => {
      selectedColor = colorKey;
      highlightActiveSwatch();
    });
    container.appendChild(swatch);
  });
}

// â”€â”€ Live Color Counter â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function updateColorCounts() {
  const counts = {};
  PALETTE_ORDER.forEach(c => { counts[c] = 0; });
  paintedColors.forEach(c => { counts[c]++; });

  PALETTE_ORDER.forEach(c => {
    const el = document.getElementById(`count-${c}`);
    el.textContent = `${counts[c]}/9`;
    el.classList.toggle('complete', counts[c] === 9);
    el.classList.toggle('over', counts[c] > 9);
  });
}
```

### 2D Net View

A flattened cross-shaped net lets users paint stickers without rotating the 3D cube:

```
              â”Œâ”€â”€â”€â”
              â”‚ U â”‚
         â”Œâ”€â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”
         â”‚ L  â”‚ F â”‚ R  â”‚ B  â”‚
         â””â”€â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”€â”´â”€â”€â”€â”€â”˜
              â”‚ D â”‚
              â””â”€â”€â”€â”˜
```

Each cell in the net is a clickable `<div>` that updates `paintedColors[index]` when clicked with the selected color.

### Step-by-Step Playback

The right panel shows the solution as a numbered list with navigation controls:

```javascript
// â”€â”€ Parse Solution into Steps â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function parseSolution(solutionStr) {
  return solutionStr.trim().split(/\s+/).filter(Boolean);
}

// â”€â”€ Generate Human-Readable Description â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function describeMove(move) {
  const faceNames = {
    U: 'Top', D: 'Bottom', R: 'Right',
    L: 'Left', F: 'Front', B: 'Back'
  };
  const face = move[0];
  const name = faceNames[face] || face;

  if (move.includes("'")) return `Rotate ${name} face 90Â° counter-clockwise`;
  if (move.includes('2'))  return `Rotate ${name} face 180Â°`;
  return `Rotate ${name} face 90Â° clockwise`;
}

// â”€â”€ Step Navigation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function goToStep(targetStep) {
  // Restore cube to initial state
  cubeObj = new Cube(savedCubeJSON);

  // Re-apply moves 0 through targetStep
  for (let i = 0; i <= targetStep; i++) {
    cubeObj.move(solveSteps[i]);
  }

  currentStep = targetStep;
  const colors = cubeStringToColors(cubeObj.asString());
  updateDisplayFromColors(colors);
  highlightCurrentStep();
  updateProgressBar();
}
```

**Playback controls:**

| Control | Function |
|---------|----------|
| **Previous** | Navigate to the prior step (rebuilds state from checkpoint) |
| **Next** | Animate and apply the next move |
| **Play / Pause** | Auto-advance through remaining steps |
| **Speed Slider** | Adjust animation duration (100ms â€“ 2000ms) |
| **Progress Bar** | Visual indicator of current position in solution |

---

## Customization Guide

### Changing Cube Colors

Modify `DISPLAY_COLORS` to change the visual appearance. The keys (`W`, `Y`, `R`, `O`, `B`, `G`) are internal identifiers â€” only the hex values matter for rendering:

```javascript
// Example: Pastel color scheme
const DISPLAY_COLORS = {
  W: '#f0f0f0',   // Light grey instead of pure white
  Y: '#ffe066',   // Soft yellow
  R: '#ff6b6b',   // Soft red
  O: '#ffa94d',   // Soft orange
  B: '#4dabf7',   // Light blue
  G: '#51cf66',   // Light green
};
```

### Adjusting Scramble Length

```javascript
// Fewer moves = easier scramble, more moves = more random
const SCRAMBLE_MOVE_COUNT = 25; // Default: 25 (range: 1â€“100)
```

For a truly random-looking scramble, 20â€“30 moves is sufficient. The cube reaches a statistically uniform random state after ~20 moves.

### Modifying Animation Speed

```javascript
// Milliseconds per move animation
const ANIMATION_DURATION_MS = 400; // Default: 400

// Slower (good for learning):
const ANIMATION_DURATION_MS = 800;

// Faster (good for demonstrations):
const ANIMATION_DURATION_MS = 150;
```

The speed slider in the UI overrides this default at runtime.

### Canvas and Layout Sizing

```javascript
// Canvas resolution (also set via HTML attributes)
const CANVAS_WIDTH = 500;
const CANVAS_HEIGHT = 500;

// 3D projection parameters
const CAMERA_DISTANCE = 8;    // Increase for less perspective
const PROJECTION_SCALE = 200; // Increase for larger cube
```

```css
/* Panel widths â€” adjust for different screen layouts */
.left-panel  { width: 220px; }
.center-panel { flex: 1; min-width: 400px; }
.right-panel { width: 280px; }
```

### Adding New Move Descriptions

Extend `describeMove()` to add context-specific hints:

```javascript
function describeMove(move) {
  const faceNames = {
    U: 'Top (White)',
    D: 'Bottom (Yellow)',
    R: 'Right (Red)',
    L: 'Left (Orange)',
    F: 'Front (Green)',
    B: 'Back (Blue)',
  };
  // ... rest of function
}
```

---

## Troubleshooting

| Issue | Cause | Solution |
|-------|-------|----------|
| "Invalid: X has N stickers (need 9)" | Incorrect number of a color painted | Check the color counter â€” each color must show 9/9 |
| "Center stickers must be unique" | Two faces have the same center color | Ensure all 6 center stickers (index 4,13,22,31,40,49) are different |
| "Could not solve â€” impossible state" | Invalid corner twist, edge flip, or permutation parity | On a real cube, only states reachable by legal moves are solvable. Reassemble or re-paint |
| Solver takes > 5 seconds on init | Normal â€” pruning tables are being computed | Wait for the status indicator to show "Ready" |
| Cube appears black / no stickers | Canvas size is 0 or CSS is hiding it | Check that the canvas element has non-zero width/height |
| Steps don't match the 3D view | State drift from old dual-state bug | Ensure you're using the latest version with the dual source-of-truth model |

---

## Dependencies

**None.** The entire application â€” including the cubejs solver library â€” is inlined in a single HTML file.

For reference, the inlined library is:

| Library | Version | Author | License | Purpose |
|---------|---------|--------|---------|---------|
| [cubejs](https://github.com/ldez/cubejs) | 1.3.x | Petri Lehtinen (akheron) | MIT | Kociemba Two-Phase Algorithm solver |

---

## Project Structure

```
rubiks-cube-solver/
â”œâ”€â”€ index.html          # Everything â€” HTML, CSS, JS, solver
â”œâ”€â”€ README.md           # This file
â””â”€â”€ LICENSE             # MIT License
```

That's it. One file. No `node_modules`, no `package.json`, no `webpack.config.js`.

---

## Contributing

Contributions are welcome. Some ideas for improvement:

- **WebGL rendering** â€” Replace Canvas 2D with WebGL or Three.js for smoother visuals and proper lighting.
- **Mobile optimization** â€” Improve touch handling and responsive layout for small screens.
- **Solution phases** â€” Group moves by solving phase (cross, F2L, OLL, PLL) with explanatory labels.
- **Undo/redo for painting** â€” Add a history stack for the paint mode.
- **Import/export** â€” Allow pasting a facelet string or scramble algorithm.
- **Accessibility** â€” Add keyboard navigation and screen reader support.
- **Internationalization** â€” Translate move descriptions and UI labels.

To contribute:

1. Fork the repository.
2. Create a feature branch: `git checkout -b feature/your-feature`
3. Commit your changes: `git commit -m 'Add your feature'`
4. Push to the branch: `git push origin feature/your-feature`
5. Open a Pull Request.

---

## License

This project is licensed under the **MIT License**. See [LICENSE](LICENSE) for details.

The inlined cubejs library is also MIT-licensed. See [cubejs LICENSE](https://github.com/ldez/cubejs/blob/master/LICENSE).

---

## Acknowledgments

- **Herbert Kociemba** â€” Creator of the [Two-Phase Algorithm](http://kociemba.org/cube.htm) that makes sub-second solving possible.
- **Petri Lehtinen (akheron)** â€” Author of the original [cube.js](https://github.com/akheron/cubejs) CoffeeScript implementation.
- **ldez** â€” Maintainer of the [cubejs fork](https://github.com/ldez/cubejs) used in this project.
- **Erno Rubik** â€” For inventing the puzzle that launched a thousand algorithms.
```

---
